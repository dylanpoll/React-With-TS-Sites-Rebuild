import "reflect-metadata";
import "dotenv-safe/config";
import cors from "cors";
import { MikroORM } from "@mikro-orm/core";
import { COOKIE_NAME, __prod__ } from "./constants";
import mikroConfig from "./mikro-orm.config";
import  express  from "express";
import { ApolloServer } from "apollo-server-express";
import { buildSchema } from "type-graphql";
import { PostResolver } from "./resolvers/post";
import { UserResolver } from './resolvers/user';
import { MyContext } from './types';
import Redis from "ioredis";//redis idle client timeout is set to 300 seconds at current. I am currently using my VPS hosted redis for development https://redis.io/commands/auth for more info on the params I am using
import session from "express-session";
import connectRedis from 'connect-redis';

    const main = async () => {
        const orm = await MikroORM.init(mikroConfig);// I will not be automating the migrations process as I would rather manually handle migrations.
        const app = express();
        // @ts-ignore
        const RedisStore = connectRedis(session);
        const redis = new Redis(process.env.REDIS_URL_VPS, { password: process.env.REDIS_PASSWORD });
        app.set("trust proxy", 1); //the following for trust proxy and the next app.use are about setting up cors. see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
        app.use( cors({ origin: process.env.CORS_ORIGIN, credentials: true, }) );
        app.use(// @ts-ignore
        session({
            name: COOKIE_NAME,// @ts-ignore
            store: new RedisStore({ // @ts-ignore
                client: redis,          //this is using ioredis because this is TS and we don't want to use the standard redis module
                disableTouch: true ,    // touching is used to keep a connected user auth token active, disabling this means they can sit idle and not have auth expire. less secure
                }),
            cookie: {
                maxAge: 1000 * 60 * 60 * 24 * 365 * 10 ,    //this sets the age for the cookie to 10 years
                httpOnly: true,
                sameSite: "lax", // may need to change this... remember updates and issues with other projects and security settings 
                secure: __prod__, // cookie only works in https
                domain: __prod__ ? ".devdylan.me" : undefined,  // this works with cors and more or less outlines where the cookie is valid and to be used
                },
            saveUninitialized: false,  // @ts-ignore     //creates a session by default, so to prevent that we turn it to false.
            secret: process.env.SESSION_SECRET,
            resave: false,
            })
        );
        // @ts-ignore 
        const apolloServer = new ApolloServer({ schema: await buildSchema({ resolvers: [PostResolver, UserResolver], validate: false }), context: ({req, res}): MyContext =>  ({ em: orm.em, req, res }), }); // apollo is running the middlewares working with graphQL this contains type definitions for it to use among other things.
        apolloServer.applyMiddleware({ app, cors: false });
        app.listen(4000, () => { console.log('express is running'); });
    };
declare module "express-session" { interface Session { userId: number; }  };
console.log("starting up the project.");
main().catch((err) => {
    console.error(err);
});
/*  
following bens tutorial for this project, will use to re learn react with typescript and familiarize further with SQL and to learn graphQL after this I will re build my websites and projects that warrant revamping.
https://www.youtube.com/watch?v=I6ypD7qv3Z8

migrations just prep the db for schemas we submit to it for SQL db
REMEMBER TO ADD NEW ENTITIES TO MIKROORM CONFIG!!!
AND RESOLVERS TO INDEX APOLLO!

TO SIGN IN TO DB 
psql -U postgres   
CREATE USER ***username*** WITH SUPERUSER ENCRYPTED PASSWORD '****password*****';
mikroORM handles database access 
=============

Notes: 
----sessions breakdown.
  redis is a "key value store" and essentially what that boils down to is that it is keeping a active log
of generated tokens/keys, the client source assigned to those keys, the paramaters of said key and keeps a socket open for said keys/tokens.
this occurs when the process for assigning a property like a cookie property or any other key/token within redis first.
  the express session reads the generated token/key from redis and assigns it a cookie id and puts it into a cookie property so the client side/browser can retain the information
so the session that a client has with our server can stay active and is used as a check to validate who is connected to what account.
  whenever a client makes any request, or leaves and comes back this cookie is sent to the server for validation and re assignment.
it takes the cookie value that is stored and uses that to re connect the client to the active token/key associated with that cookies code generated by our secrete.
  when it sends the cookie key to the redis server, the redis server turns the cookie key into the redis session, and returns the data initially requested that is associated with the cookie.
tdlr
  1) user data generated(logs in) -> redis assigned session -> cookie key created with secrete -> cookie updated with current cookie key
  2) request made(userid or is authenticated?) -> cookie key -> redis session key -> requested user data

about CORS https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
  CORS is used to validate sessions accross multiple website exchanges.

-----typescript 
  works with types....so it sometimes is a good idea to set object types to const



*/